name: Build and test

on:
  push:
    branches:
      - main
    tags:
      - "v*.*.*"
  pull_request:
    branches:
      - main

permissions:
  contents: write

env:
  NSS_VERSION: nss-3.92
  BORING_SSL_COMMIT: d24a38200fef19150eef00cad35b138936c08767

jobs:
  build-and-test-linux:
    name: (Linux x86_64) Build curl-impersonate and run the tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          docker build -t curl-impersonate-builder -f - . << "EOF"
            FROM quay.io/pypa/manylinux2014_x86_64:latest
            RUN python3.9 -m pip install ninja cmake && \
                curl -o /tmp/go.tar.gz -L https://go.dev/dl/go1.19.10.linux-amd64.tar.gz & \
                tar -C /usr/local -xzf /tmp/go.tar.gz
            ENV PATH=/usr/local/go/bin:/opt/_internal/cpython-3.9.18/bin:$PATH
          EOF

      - name: Check out the repo
        uses: actions/checkout@v2

      # Cache the build of BoringSSL, which is the longest part of the build
      # We must cache the .zip as well, otherwise the Makefile will
      # rebuild BoringSSL. This whole thing is a bit hacky, but necessary to
      # reduce the insanely long build times.
      - name: Cache BoringSSL source
        uses: actions/cache@v3
        with:
          path: boringssl.zip
          key: ${{ runner.os }}-${{ matrix.arch }}-boring-source-${{ env.BORING_SSL_COMMIT }}

      - name: Cache BoringSSL build
        id: cache-boringssl
        uses: actions/cache@v3
        with:
          path: boringssl/build
          key: ${{ runner.os }}-${{ matrix.arch }}-boring-build-${{ env.BORING_SSL_COMMIT }}-${{ hashFiles('chrome/patches/boringssl*.patch') }}

      # Trick the Makefile into skipping the BoringSSL build step
      # if it was found in the cache. See Makefile.in
      - name: Post BoringSSL cache restore
        if: ${{ steps.cache-boringssl.outputs.cache-hit != false }}
        run: |
          touch boringssl.zip
          touch boringssl/.patched
          find boringssl/build -type f | xargs touch

      # Cache the build of NSS, which is the longest part of the build
      # We must cache the .tar.gz as well, otherwise the Makefile will
      # rebuild NSS.
      - name: Cache NSS source
        uses: actions/cache@v3
        with:
          path: ${{ env.NSS_VERSION }}.tar.gz
          key: ${{ runner.os }}-${{ matrix.arch }}-nss-source-${{ env.NSS_VERSION }}

      - name: Cache NSS build
        id: cache-nss
        uses: actions/cache@v3
        with:
          path: ${{ env.NSS_VERSION }}/dist
          key: ${{ runner.os }}-${{ matrix.arch }}-nss-build-${{ env.NSS_VERSION }}

      # Trick the Makefile into skipping the NSS build step
      # if it was found in the cache.
      - name: Post NSS cache restore
        if: ${{ steps.cache-nss.outputs.cache-hit != false }}
        run: |
          touch ${{ env.NSS_VERSION }}.tar.gz
          find ${{ env.NSS_VERSION }}/dist -type f | xargs touch

      - name: Run build in manylinux docker
        uses: addnab/docker-run-action@v3
        with:
          image: curl-impersonate-builder
          options: -v ${{ github.workspace }}:/work --workdir /work
          run: |
            set -e
            mkdir /tmp/install
            ./configure --prefix=/tmp/install

            make chrome-build
            make chrome-checkbuild
            make chrome-install
            make firefox-build
            make firefox-checkbuild
            make firefox-install